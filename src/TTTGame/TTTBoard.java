package TTTGame;

import Listener.TTTEndEvent;
import Listener.TTTEndListener;
import Listener.TTTResetListener;
import Listener.TTTWonEvent;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.HashSet;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.Border;
/**
 *
 * @author luigi
 */
public class TTTBoard extends JFrame implements PropertyChangeListener, TTTResetListener{

    private static final int BOARD_SIZE = 3;
    private static final int MIN_MOVES = 5;
    private static final int FULL_BOARD = 9;

    private final TTTCell[][] matrix = new TTTCell[BOARD_SIZE][BOARD_SIZE];
    private TTTController ctlLbl;
    private final JButton btnRestart = new JButton("Restart!");

    private enum winPattern { COL, ROW, DIAG, ANTIDIAG };
    private int move = 0;
    private ArrayList<TTTResetListener> resetListeners = new ArrayList<>();
    private ArrayList<TTTEndListener> endListeners = new ArrayList<>();
    
    public GameState state = GameState.GAME_START;

    
    /**
     * Creates new form TTTBoard
     */
    public TTTBoard() {
        initComponents();
    }
    
    private void setGrid()
    {
        this.ctlLbl = new TTTController(this);

        GridLayout experimentLayout = new GridLayout(BOARD_SIZE+1,BOARD_SIZE);
        this.setLayout(experimentLayout);
               
        resetListeners.add(ctlLbl);     
        endListeners.add(ctlLbl);     

        for(int i=0; i< BOARD_SIZE; i++)
        {
            for(int j=0; j < BOARD_SIZE; j++)
            {
                    matrix[i][j] = new TTTCell();
                    matrix[i][j].addPropertyChangeListener(this);
                    matrix[i][j].addVetoableChangeListener(ctlLbl);
                    resetListeners.add(matrix[i][j]);
                    endListeners.add(matrix[i][j]);
                    this.add(matrix[i][j]);
                    
                }
        }

        this.add(ctlLbl); 
        // dummy entry
        this.add(new JPanel());
        
        btnRestart.addActionListener((ActionEvent e) -> {
            reset();
        });
        
        this.add(btnRestart);
        this.setVisible(true);
    }
    
    /**
     *
     */
    @Override
    public void reset()
    {
        //back to start game
        state = GameState.GAME_START;
        resetListeners.forEach((tttResetListener) -> tttResetListener.reset());
        //move numreset
        move = 0;
      

    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("TTTGame");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                TTTBoard board = new TTTBoard();
                board.setGrid();
            }
        });
    }
    
    private void setWinner(TTTCell winnerCell, winPattern pat, int pos)
    {
        TTTWonEvent evt = new TTTWonEvent(winnerCell);
        ctlLbl.onEnd(evt);
        HashSet<TTTCell> wonCell = new HashSet<>();
        switch(pat){
        
            case COL:
            {   
                for(int i=0, j = pos; i < BOARD_SIZE; i++)
                {
                    matrix[i][j].onEnd(evt);
                    wonCell.add(matrix[i][j]);
                }
                break;
            }
            case ROW:
            {     
                for(int i=pos, j=0; j < BOARD_SIZE;j++)
                {
                    matrix[i][j].onEnd(evt);
                    wonCell.add(matrix[i][j]);
                }
                
                break;
            }
        
            case DIAG:
            {     
                for(int i=0,j=0; j < BOARD_SIZE;i++,j++)
                {
                    matrix[i][j].onEnd(evt);
                    wonCell.add(matrix[i][j]);
                }
                break;
            }
        
            case ANTIDIAG:
            {     
                for(int i=0,j=BOARD_SIZE-1; i < BOARD_SIZE;i++,j--)
                {
                    matrix[i][j].onEnd(evt);
                    wonCell.add(matrix[i][j]);
                }
                break;
            }
        }
        // need to disable other board's TTTCells
        for(int i=0; i < BOARD_SIZE; i++)
            for(int j=0; j < BOARD_SIZE; j++)
            {
                if(!wonCell.contains(matrix[i][j]))
                {
                    TTTEndEvent endDisable = new TTTEndEvent(this);
                    matrix[i][j].onEnd(endDisable);
                }
            }
            
    }
    @Override
    public void propertyChange(PropertyChangeEvent pce) {
        
        move++;
        if(move >= MIN_MOVES)
        {
            //rows check
            for(int i=0,j=0; i< BOARD_SIZE; i++)
            {
                if(matrix[i][j].getState()!= TTTCell.TTTState.INITIAL 
                && matrix[i][j].getState() == matrix[i][j+1].getState() 
                && matrix[i][j+1].getState() == matrix[i][j+2].getState())
                {
                    setWinner(matrix[i][j],winPattern.ROW, i);
                    state = matrix[i][j+2].getState() == TTTCell.TTTState.O? GameState.WIN_O : GameState.WIN_X;
                }

            }
            //column check
             for(int j=0,i=0; i< BOARD_SIZE; i++)
            {
                if(matrix[j][i].getState()!= TTTCell.TTTState.INITIAL 
                && matrix[j][i].getState() == matrix[j+1][i].getState() 
                && matrix[j+1][i].getState() == matrix[j+2][i].getState())
                {
                    setWinner(matrix[i][j],winPattern.COL, i);
                    state = matrix[j+2][i].getState() == TTTCell.TTTState.O? GameState.WIN_O : GameState.WIN_X;

                }
            }
            //diagonal check
            for(int j=0,i=0; i< BOARD_SIZE-1; i++,j++)
            {
                if(matrix[j][i].getState()!= TTTCell.TTTState.INITIAL 
                && matrix[j][i].getState() == matrix[j+1][i+1].getState())
                {
                    if(i==BOARD_SIZE-2)
                    {
                        setWinner(matrix[i][j],winPattern.DIAG, 0);
                state = matrix[j+1][i+1].getState() == TTTCell.TTTState.O? GameState.WIN_O : GameState.WIN_X;
                    }
                }
                else
                    i=BOARD_SIZE;
                
            }
            //anti-diagonal check
            for(int i=0,j=BOARD_SIZE-1; j > 0; i++,j--)
            {
                if(matrix[i][j].getState()!= TTTCell.TTTState.INITIAL 
                && matrix[i][j].getState() == matrix[i+1][j-1].getState())
                {
                    if(i==1)
                    {
                        setWinner(matrix[i][j],winPattern.ANTIDIAG, 0);
                        state = matrix[i+1][j-1].getState() == TTTCell.TTTState.O? GameState.WIN_O : GameState.WIN_X;

                    }
                }
                else
                    j=0;
                
            }
        }
        boolean win = state == GameState.WIN_X || state == GameState.WIN_O;
        if(move == FULL_BOARD && !win)
        {
                TTTEndEvent end = new TTTEndEvent(this);
                ctlLbl.onEnd(end);                
        }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    }
}